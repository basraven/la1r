#!/usr/bin/env python3
import http.server
import socketserver
import RPi.GPIO as GPIO
import argparse
import time
import sys
import subprocess
import logging
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# PWM Ruck fan control
PWM_PIN = 18  # GPIO18 (Pin 12)
FREQUENCY = 25000  # 25 kHz for PWM frequency
duty_cycle = 0.0  # Initial duty cycle

# Dictionary to store the switch GPIO pins and corresponding IP addresses to ping
SWITCH_CONFIG = {
    1: {'pin': 17, 'ip': '192.168.5.1'},
    3: {'pin': 22, 'ip': '192.168.5.3'}
}

# Dictionary to store the last switch-on timestamps
last_switch_on_time = {switch: None for switch in SWITCH_CONFIG.keys()}

# Cooldown period in seconds (2 minutes)
COOLDOWN_PERIOD = 2 * 60

# Thread pool for asynchronous tasks
executor = ThreadPoolExecutor(max_workers=4)

# Setup GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setup(PWM_PIN, GPIO.OUT)
pwm = GPIO.PWM(PWM_PIN, FREQUENCY)
pwm.start(duty_cycle)

for config in SWITCH_CONFIG.values():
    GPIO.setup(config['pin'], GPIO.OUT)
    GPIO.output(config['pin'], GPIO.LOW)

# PWM Set fan speed
def set_fan_speed(duty_cycle):
    pwm.ChangeDutyCycle(duty_cycle)

def ping_ip(ip):
    """Ping an IP address and return whether it's reachable."""
    try:
        result = subprocess.run(['ping', '-c', '1', ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=3)
        return result.returncode == 0
    except subprocess.TimeoutExpired:
        logging.error(f"Timeout expired when pinging IP {ip}")
        return False
    except Exception as e:
        logging.error(f"Error pinging IP {ip}: {e}")
        return False

def handle_switch_action(switch_number, action):
    """Handle the action for a given switch number."""
    if switch_number not in SWITCH_CONFIG:
        logging.error(f"Switch number {switch_number} not found")
        return "Switch number not found"

    config = SWITCH_CONFIG[switch_number]
    pin = config['pin']
    ip = config['ip']
    last_on_time = last_switch_on_time.get(switch_number)

    if action == 'on':
        if last_on_time and (datetime.now() - last_on_time).total_seconds() < COOLDOWN_PERIOD:
            cooldown_remaining = COOLDOWN_PERIOD - (datetime.now() - last_on_time).total_seconds()
            return f"Cooldown period active. Please wait {cooldown_remaining:.0f} seconds before switching on again."

        if not ping_ip(ip):
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(1)
            GPIO.output(pin, GPIO.LOW)
            last_switch_on_time[switch_number] = datetime.now()
            return f"Server {switch_number} is switched ON"
        else:
            last_switch_on_time[switch_number] = datetime.now()
            return f"Server {switch_number} is already ON"

    elif action == 'off':
        if ping_ip(ip):
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(5)
            GPIO.output(pin, GPIO.LOW)
            return f"Server {switch_number} is switched OFF"
        else:
            return f"Server {switch_number} is already OFF"

    elif action == 'status':
        return f"Server {switch_number} at {ip} is {'ON' if ping_ip(ip) else 'OFF'}"

    else:
        return "Unknown action"

class MyRequestHandler(http.server.SimpleHTTPRequestHandler):
    fan_speed = 0
    def do_GET(self):
        if self.path.startswith('/switch/'):
            parts = self.path.strip('/').split('/')
            if len(parts) != 3:
                self.send_error(400, 'Bad Request: Invalid request format')
                return

            try:
                switch_number = int(parts[1])
                action = parts[2]
                response_message = handle_switch_action(switch_number, action)

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_message.encode())
            except ValueError:
                self.send_error(400, 'Bad Request: Invalid switch number or action')
        elif self.path.startswith('/fan/'):
            parts = self.path.strip('/').split('/')
            if len(parts) != 2:
                self.send_error(400, 'Bad Request: Invalid request format')
                return
            try:
                if 'status' in parts[1]:
                    response_message = f'fan speed is {MyRequestHandler.fan_speed}'
                else:
                    fan_speed = int(parts[1])
                    if not 0 <= fan_speed <= 100:
                        self.send_error(400, 'Bad Request: Invalid fan speed')
                        return
                    MyRequestHandler.fan_speed = fan_speed
                    executor.submit(set_fan_speed, fan_speed)
                    response_message = f'fan speed set to {fan_speed}'

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_message.encode())
            except ValueError:
                self.send_error(400, 'Bad Request: Invalid fan speed')
        else:
            self.send_error(404, 'Not Found')

def main():
    parser = argparse.ArgumentParser(
        description='Control multiple GPIO switches via REST API or command line.',
        epilog='Examples:\n'
               '  python3 server.py 1 on                  # Turn on switch 1\n'
               '  python3 server.py 2 off                 # Turn off switch 2\n'
               '  python3 server.py 3 status              # Check the status of the external service for switch 3\n'
               '  python3 server.py                       # Start the REST API server with default port 49250\n'
               '  python3 server.py -p 8080               # Start the REST API server on port 8080\n'
               '  REST API Documentation:\n'
               '  GET /switch/<switch_number>/on          # Turns on the switch specified by <switch_number>\n'
               '  GET /switch/<switch_number>/off         # Turns off the switch specified by <switch_number>\n'
               '  GET /switch/<switch_number>/status      # Checks the status of the external service for the switch\n'
               '  GET /fan/<fan_speed>/                   # Set fan speed between 0 and 100\n'
               '  Command line options:\n'
               '    -p PORT, --port PORT  Specify the port number for the HTTP server (default: 49250)\n',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('switch_number', type=int, nargs='?', help='The switch number to control')
    parser.add_argument('action', type=str, nargs='?', choices=['on', 'off', 'status'], help='Action to perform on the switch (on, off, status)')
    parser.add_argument('-p', '--port', type=int, default=49250, help='Port number for the HTTP server (default: 49250)')

    args = parser.parse_args()

    # Ensure GPIO is cleaned up properly on exit
    try:
        if args.switch_number and args.action:
            result_message = handle_switch_action(args.switch_number, args.action)
            print(result_message)
            pwm.stop()
            GPIO.cleanup()
            sys.exit(0)

        # Start the HTTP server if no command line arguments are provided
        PORT = args.port
        with socketserver.TCPServer(("", PORT), MyRequestHandler) as httpd:
            logging.info(f"Serving on port {PORT}")
            httpd.serve_forever()
    except KeyboardInterrupt:
        logging.info("Server stopped")
    finally:
        # Cleanup GPIO states
        for config in SWITCH_CONFIG.values():
            GPIO.output(config['pin'], GPIO.LOW)
        pwm.stop()
        GPIO.cleanup()
        logging.info("GPIO cleaned up")
        executor.shutdown(wait=False)

if __name__ == '__main__':
    main()
