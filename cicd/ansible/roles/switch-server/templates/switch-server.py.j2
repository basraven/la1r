#!/usr/bin/env python3
import http.server
import socketserver
import RPi.GPIO as GPIO
import argparse
import time
import sys
import subprocess
import logging
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
import threading

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# PWM Ruck fan control
PWM_PIN = 18  # GPIO18 (Pin 12)
FREQUENCY = 25000  # 25 kHz for PWM frequency
duty_cycle = 0.0  # Initial duty cycle

# Dictionary to store the switch GPIO pins and corresponding IP addresses to ping
SWITCH_CONFIG = {
    1: {'pin': 17, 'ip': '192.168.5.1'},
    3: {'pin': 22, 'ip': '192.168.5.3'}
}

# Dictionary to store the last switch-on timestamps
last_switch_on_time = {switch: None for switch in SWITCH_CONFIG.keys()}

# Cooldown period in seconds (2 minutes)
COOLDOWN_PERIOD = 2 * 60

# Thread pool for asynchronous tasks
executor = ThreadPoolExecutor(max_workers=4)

# Setup GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setup(PWM_PIN, GPIO.OUT)
pwm = GPIO.PWM(PWM_PIN, FREQUENCY)
pwm.start(duty_cycle)

for config in SWITCH_CONFIG.values():
    GPIO.setup(config['pin'], GPIO.OUT)
    GPIO.output(config['pin'], GPIO.LOW)

# LED setup
LED_PIN = 26
GPIO.setup(LED_PIN, GPIO.OUT)

# Switch GPIO 16 setup
SWITCH_16_PIN = 16
GPIO.setup(SWITCH_16_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Assuming pull-up resistor

# Track the previous state of GPIO 16
previous_switch_16_state = GPIO.HIGH

# Function to handle switch actions
def handle_switch_action(switch_number, action):
    """Handle the action for a given switch number."""
    if switch_number not in SWITCH_CONFIG:
        logging.error(f"Switch number {switch_number} not found")
        return "Switch number not found"

    config = SWITCH_CONFIG[switch_number]
    pin = config['pin']
    ip = config['ip']
    last_on_time = last_switch_on_time.get(switch_number)

    if action == 'on':
        if last_on_time and (datetime.now() - last_on_time).total_seconds() < COOLDOWN_PERIOD:
            cooldown_remaining = COOLDOWN_PERIOD - (datetime.now() - last_on_time).total_seconds()
            return f"Cooldown period active. Please wait {cooldown_remaining:.0f} seconds before switching on again."

        if not ping_ip(ip):
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(1)
            GPIO.output(pin, GPIO.LOW)
            last_switch_on_time[switch_number] = datetime.now()
            return f"Server {switch_number} is switched ON"
        else:
            last_switch_on_time[switch_number] = datetime.now()
            return f"Server {switch_number} is already ON"

    elif action == 'off':
        if ping_ip(ip):
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(5)
            GPIO.output(pin, GPIO.LOW)
            return f"Server {switch_number} is switched OFF"
        else:
            return f"Server {switch_number} is already OFF"

    elif action == 'status':
        return f"Server {switch_number} at {ip} is {'ON' if ping_ip(ip) else 'OFF'}"

    else:
        return "Unknown action"

# Function to ping an IP address
def ping_ip(ip):
    """Ping an IP address and return whether it's reachable."""
    try:
        result = subprocess.run(['ping', '-c', '1', ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=3)
        return result.returncode == 0
    except subprocess.TimeoutExpired:
        logging.error(f"Timeout expired when pinging IP {ip}")
        return False
    except Exception as e:
        logging.error(f"Error pinging IP {ip}: {e}")
        return False

# Function to check the status of switches and control the LED
def check_switch_and_control_led():
    global previous_switch_16_state
    last_ping_time = time.time()
    blink_interval = 0.1  # Time in seconds for the LED to stay on or off
    led_on_time = time.time()
    led_state = GPIO.LOW
    switch_1_blinking = False

    while True:
        current_time = time.time()

        # Check if we need to toggle the LED state for blinking
        if switch_1_blinking and current_time - led_on_time >= blink_interval:
            led_state = GPIO.HIGH if led_state == GPIO.LOW else GPIO.LOW
            GPIO.output(LED_PIN, led_state)
            led_on_time = current_time

        # Manage switch states and control the LED based on switch states
        if current_time - last_ping_time >= 10:  # Check switches every 10 seconds
            switch_1_status = not ping_ip(SWITCH_CONFIG[1]['ip'])  # True if switch 1 is off
            switch_3_status = ping_ip(SWITCH_CONFIG[3]['ip'])  # True if switch 3 is on

            current_switch_16_state = GPIO.input(SWITCH_16_PIN)
            if current_switch_16_state == GPIO.LOW and previous_switch_16_state == GPIO.HIGH:
                # GPIO 16 has just been pressed
                response_message = handle_switch_action(3, 'on')
                logging.info(f"GPIO 16 pressed. {response_message}")
                time.sleep(1)  # Debounce delay

            # Update previous state of GPIO 16
            previous_switch_16_state = current_switch_16_state

            if switch_3_status:
                # Turn LED on if switch 3 is on
                GPIO.output(LED_PIN, GPIO.HIGH)
                switch_1_blinking = False  # Disable blinking
            elif switch_1_status:
                # Enable blinking if switch 1 is off
                switch_1_blinking = True
                led_state = GPIO.LOW  # Ensure LED starts off for blinking
            else:
                # Default to LED off if neither condition is met
                GPIO.output(LED_PIN, GPIO.LOW)
                switch_1_blinking = False

            last_ping_time = current_time

        # Small sleep to avoid high CPU usage
        time.sleep(0.01)

    # Cleanup will never be reached due to infinite loop
    # Add this for completeness if you decide to add a stopping condition
    GPIO.cleanup()
    logging.info("LED monitoring stopped")

# Start the switch checking and LED control in a separate thread
threading.Thread(target=check_switch_and_control_led, daemon=True).start()

# PWM Set fan speed
def set_fan_speed(duty_cycle):
    pwm.ChangeDutyCycle(duty_cycle)

class MyRequestHandler(http.server.SimpleHTTPRequestHandler):
    fan_speed = 0
    def do_GET(self):
        if self.path.startswith('/switch/'):
            parts = self.path.strip('/').split('/')
            if len(parts) != 3:
                self.send_error(400, 'Bad Request: Invalid request format')
                return

            try:
                switch_number = int(parts[1])
                action = parts[2]
                response_message = handle_switch_action(switch_number, action)

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_message.encode())
            except ValueError:
                self.send_error(400, 'Bad Request: Invalid switch number or action')
        elif self.path.startswith('/fan/'):
            parts = self.path.strip('/').split('/')
            if len(parts) != 2:
                self.send_error(400, 'Bad Request: Invalid request format')
                return
            try:
                if 'status' in parts[1]:
                    response_message = f'fan speed is {MyRequestHandler.fan_speed}'
                else:
                    fan_speed = int(parts[1])
                    if not 0 <= fan_speed <= 100:
                        self.send_error(400, 'Bad Request: Invalid fan speed')
                        return
                    MyRequestHandler.fan_speed = fan_speed
                    executor.submit(set_fan_speed, fan_speed)
                    response_message = f'fan speed set to {fan_speed}'

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_message.encode())
            except ValueError:
                self.send_error(400, 'Bad Request: Invalid fan speed')
        else:
            self.send_error(404, 'Not Found')

def main():
    parser = argparse.ArgumentParser(
        description='Control multiple GPIO switches via REST API or command line.',
        epilog='Examples:\n'
               '  python3 server.py 1 on                  # Turn on switch 1\n'
               '  python3 server.py 2 off                 # Turn off switch 2\n'
               '  python3 server.py 3 status              # Check the status of the external service for switch 3\n'
               '  python3 server.py                       # Start the REST API server with default port 49250\n'
               '  python3 server.py -p 8080               # Start the REST API server on port 8080\n'
               '  REST API Documentation:\n'
               '  GET /switch/<switch_number>/on          # Turns on the switch specified by <switch_number>\n'
               '  GET /switch/<switch_number>/off         # Turns off the switch specified by <switch_number>\n'
               '  GET /switch/<switch_number>/status      # Checks the status of the external service for the switch\n'
               '  GET /fan/<fan_speed>/                   # Set fan speed between 0 and 100\n'
               '  Command line options:\n'
               '    -p PORT, --port PORT  Specify the port number for the HTTP server (default: 49250)\n',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('switch_number', type=int, nargs='?', help='The switch number to control')
    parser.add_argument('action', type=str, nargs='?', choices=['on', 'off', 'status'], help='Action to perform on the switch (on, off, status)')
    parser.add_argument('-p', '--port', type=int, default=49250, help='Port number for the HTTP server (default: 49250)')

    args = parser.parse_args()

    # Ensure GPIO is cleaned up properly on exit
    try:
        if args.switch_number and args.action:
            result_message = handle_switch_action(args.switch_number, args.action)
            print(result_message)
            pwm.stop()
            GPIO.cleanup()
            sys.exit(0)

        # Start the HTTP server if no command line arguments are provided
        PORT = args.port
        with socketserver.TCPServer(("", PORT), MyRequestHandler) as httpd:
            logging.info(f"Serving on port {PORT}")
            httpd.serve_forever()
    except KeyboardInterrupt:
        logging.info("Server stopped")
    finally:
        # Cleanup GPIO states
        for config in SWITCH_CONFIG.values():
            GPIO.output(config['pin'], GPIO.LOW)
        pwm.stop()
        GPIO.cleanup()
        logging.info("GPIO cleaned up")
        executor.shutdown(wait=False)

if __name__ == '__main__':
    main()
